pub struct NaieveSidewinderGenerator<'a, P: 'a + PackedArray> {
	maze: &'a mut Maze<P>,
	rng: XorShiftRng
}

impl<'a, P: PackedArray> NaieveSidewinderGenerator<'a, P> {
	pub fn new(maze: &'a mut Maze<P>) -> Self {
		NaieveSidewinderGenerator {
			maze: maze,
			rng: XorShiftRng::new_unseeded()
		}
	}
}

impl<'a, P: PackedArray> Generator for NaieveSidewinderGenerator<'a, P> {
	fn set_seed(&mut self, seed: [u32; 4]) {
		self.rng.reseed(seed);
	}
	
	fn generate(&mut self) {
		let maze = &mut *self.maze;

		for y in 0..maze.height() {
			let mut run_start = 0;

			for x in 0..maze.width() {
				if y > 0 && (x + 1 == maze.width() || self.rng.next_f64() > 0.50) {
					let carve_point =
						run_start + (self.rng.next_f64() * (x - run_start + 1) as f64) as i64;

					unsafe { maze.or_set_unchecked(carve_point, y - 1, S); }
					run_start = x + 1;
				} else if x + 1 < maze.width() {
					unsafe { maze.or_set_unchecked(x, y, E); }
				}
			}
		}
	}
}
