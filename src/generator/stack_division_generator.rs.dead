pub struct StackDivisionGenerator<'a, P: 'a + Grid> {
	maze: &'a mut Maze<P>,
	rng: XorShiftRng
}

impl<'a, P: Grid> StackDivisionGenerator<'a, P> {
	pub fn new(maze: &'a mut Maze<P>) -> Self {
		StackDivisionGenerator {
			maze: maze,
			rng: XorShiftRng::new_unseeded()
		}
	}
}

impl<'a, P: Grid> Generator for StackDivisionGenerator<'a, P> {
	fn set_seed(&mut self, seed: [u32; 4]) {
		self.rng.reseed(seed);
	}
	
	fn generate(&mut self) {
		self.maze.fill(0xFF);

		let (maze_width, maze_height) = (self.maze.width(), self.maze.height());

		// add walls on the south side of the maze
		for x in 0..self.maze.width() {
			unsafe { self.maze.unset_provided_unchecked(x, maze_height - 1, S); }
		}

		// add walls on the east side of the maze
		for y in 0..self.maze.width() {
			unsafe { self.maze.unset_provided_unchecked(maze_width - 1, y, E); }
		}

		let mut stack = Vec::with_capacity(self.maze.width() as usize);

		stack.push((0, 0, self.maze.width(), self.maze.height()));

		while stack.len() > 0 {
			let (x, y, width, height) = stack.pop().unwrap();
			let orientation =
				if self.rng.next_f64() + if height > width { 0.25_f64 } else { -0.25_f64 } > 0.5 {
					Orientation::Horizontal
				} else {
					Orientation::Vertical
				};

			if width < 2 || height < 2 {
				continue;
			}

			// where the line will start
			let (mx, my) = match orientation {
				Orientation::Horizontal => (x, y + self.rng.gen_range(0, height - 1)),
				Orientation::Vertical => (x + self.rng.gen_range(0, width - 1), y)
			};
			// in which direction we should offset each iteration
			let (dx, dy) = match orientation {
				Orientation::Horizontal => (1, 0),
				Orientation::Vertical => (0, 1)
			};
			// how long the bisector line will be
			let length = match orientation {
				Orientation::Horizontal => width,
				Orientation::Vertical => height
			};
			// where the line will have its one opening
			let opening = self.rng.gen_range(0, length);
			// in which direction we should set the bisector line
			let direction = match orientation {
				Orientation::Horizontal => S,
				Orientation::Vertical => E
			};

			// draw the dividing line 
			for i in 0..length {
				// except for where we've chosen the hole to be
				if i != opening {
					unsafe { self.maze.unset_provided_unchecked(mx + dx * i, my + dy * i, direction); }
				}
			}

			// add areas recursively to the stack
			match orientation {
				Orientation::Horizontal => {
					stack.push((x, y, width, my - y + 1));
					stack.push((x, my + 1, width, y + height - my - 1));
				},
				Orientation::Vertical => {
					stack.push((x, y, mx - x + 1, height));
					stack.push((mx + 1, y, x + width - mx - 1, height));
				}
			}
		}
	}
}
