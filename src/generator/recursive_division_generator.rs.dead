pub struct RecursiveDivisionGenerator<'a, P: 'a + Grid> {
	maze: &'a mut Maze<P>,
	rng: XorShiftRng
}

impl<'a, P: Grid> RecursiveDivisionGenerator<'a, P> {
	pub fn new(maze: &'a mut Maze<P>) -> Self {
		RecursiveDivisionGenerator {
			maze: maze,
			rng: XorShiftRng::new_unseeded()
		}
	}

	fn recursive_divide(&mut self, x: i64, y: i64, width: i64, height: i64) {
		let orientation =
			if self.rng.next_f64() + if height > width { 0.25_f64 } else { -0.25_f64 } > 0.5 {
				Orientation::Horizontal
			} else {
				Orientation::Vertical
			};

		if width < 2 || height < 2 {
			return;
		}

		// where the line will start
		let (mx, my) = match orientation {
			Orientation::Horizontal => (x, y + self.rng.gen_range(0, height - 1)),
			Orientation::Vertical => (x + self.rng.gen_range(0, width - 1), y)
		};
		// in which direction we should offset each iteration
		let (dx, dy) = match orientation {
			Orientation::Horizontal => (1, 0),
			Orientation::Vertical => (0, 1)
		};
		// how long the bisector line will be
		let length = match orientation {
			Orientation::Horizontal => width,
			Orientation::Vertical => height
		};
		// where the line will have its one opening
		let opening = self.rng.gen_range(0, length);
		// in which direction we should set the bisector line
		let direction = match orientation {
			Orientation::Horizontal => S,
			Orientation::Vertical => E
		};

		// draw the dividing line 
		for i in 0..length {
			// except for where we've chosen the hole to be
			if i != opening {
				unsafe { self.maze.unset_provided_unchecked(mx + dx * i, my + dy * i, direction); }
			}
		}

		// add areas recursively to the stack
		match orientation {
			Orientation::Horizontal => {
				self.recursive_divide(x, y, width, my - y + 1);
				self.recursive_divide(x, my + 1, width, y + height - my - 1);
			},
			Orientation::Vertical => {
				self.recursive_divide(x, y, mx - x + 1, height);
				self.recursive_divide(mx + 1, y, x + width - mx - 1, height);
			}
		}
	}
}

impl<'a, P: Grid> Generator for RecursiveDivisionGenerator<'a, P> {
	fn set_seed(&mut self, seed: [u32; 4]) {
		self.rng.reseed(seed);
	}
	
	fn generate(&mut self) {
		self.maze.fill(0xFF);

		let (maze_width, maze_height) = (self.maze.width(), self.maze.height());

		// add walls on the south side of the maze
		for x in 0..self.maze.width() {
			unsafe { self.maze.unset_provided_unchecked(x, maze_height - 1, S); }
		}

		// add walls on the east side of the maze
		for y in 0..self.maze.width() {
			unsafe { self.maze.unset_provided_unchecked(maze_width - 1, y, E); }
		}

		self.recursive_divide(0, 0, maze_width, maze_height);
	}
}
